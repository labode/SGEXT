using namespace DGtal;
using namespace functions;

template <typename TKSpace, typename TCellContainer>
bool DGtal::functions::is_reducible( CubicalComplex< TKSpace, TCellContainer > & cc,
                   bool hintIsKClosed ,
                   bool verbose )
{
  size_t voxel_dim = TKSpace::dimension ;
  // Single Voxel is the end condition of the recursive definition.
  if ( cc.nbCells(voxel_dim) == 1) return true;
  if(verbose) {
    std::cout << "nbCells"      << std::endl;
    std::cout << "MaxDim: "     << cc.nbCells(voxel_dim)     << std::endl;
    std::cout << "MaxDim - 1: " << cc.nbCells(voxel_dim - 1) << std::endl;
  }
  // It must be non-empty and connected.
  if ( cc.nbCells(voxel_dim) == 0) return false;
  //TODO:
  //if (K.isConnected == false) return false;
  // Recursion.
  // auto first = cc.lowerCells;
  // auto last  = K.upperCells;
  // auto p = first;
  // bool reducible_status = false;
  // do
  // {
  //   auto neighbors  = K.uProperNeighborhood(p);
  //   reducible_status = is_reducible(neighbors); // && is_reducible(rest_of_the_space);
  // } while( K.uNext(p, first, last) && reducible_status != true);

}
template <typename TKSpace, typename TCells>
bool DGtal::functions::is_reducible(TCells & set_of_cells)
{
  // Create a CubicalComplex K from the set of cells.
  // Apply the other is_reducible to it.
}

template <typename TKSpace, typename TCellContainer, typename TCell >
bool DGtal::functions::voxel_is_simple( CubicalComplex< TKSpace, TCellContainer > & K,
                   TCell& c,
                   bool verbose )
{

  // auto neighbors = K.uProperNeighborhood(c);
  // return is_reducible(neighbors);
}


